
for(int i = 0; i < all->sprite.count; i++)
    {
      spriteOrder[i] = i;
     spriteDistance[i] = (pow (all->plr.x - all->sprite.buf[i].x, 2) + pow(all->plr.y - all->sprite.buf[i].y, 2)); //sqrt not taken, unneeded
   // printf("%f", all->sprite.buf[i].x);
    }

for(int i = 0; i < all->sprite.count; i++)
    {
      //translate sprite position to relative to camera
        all->sprite.X = all->sprite.buf[(int)spriteOrder[i]].x - all->plr.x;
        all->sprite.Y = all->sprite.buf[(int)spriteOrder[i]].y - all->plr.y;
        all->sprite.inv = 1.0 / (all->plr.planeX * all->plr.dirY - all->plr.dirX * all->plr.planeY); //required for correct matrix multiplication
        all->sprite.tranX = all->sprite.inv * (all->plr.dirY * all->sprite.X - all->plr.dirX * all->sprite.Y);
        all->sprite.tranY = all->sprite.inv * (-all->plr.planeY * all->sprite.X + all->plr.planeX * all->sprite.Y); //this is actually the depth inall->ray.side the screen, that what Z is in 3D, the distance of sprite to player, matching sqrt(spriteDistance[i])
        all->sprite.ScreenX = (int)((all->rend.x / 2) * (1 + all->sprite.tranX / all->sprite.tranY));
        all->sprite.move_s = (int)(0.0 / all->sprite.tranY);
        all->tex[4].tex_h = abs((int)(all->rend.y / (all->sprite.tranY))) / 1; 
        all->draw.drawStartY = -all->tex[4].tex_h / 2 + all->rend.y / 2 + all->sprite.move_s;
      if(all->draw.drawStartY < 0) all->draw.drawStartY = 0;
       all->draw.drawEndY = all->tex[4].tex_h / 2 + all->rend.y / 2 + all->sprite.move_s;
      if(all->draw.drawEndY >= all->rend.y) all->draw.drawEndY = all->rend.y - 1;

      //calculate width of the sprite
      int spriteWidth = abs( (int) (all->rend.y / (all->sprite.tranY))) / 1;
       all->draw.drawStartX = -spriteWidth / 2 + all->sprite.ScreenX;
      if(all->draw.drawStartX < 0) all->draw.drawStartX = 0;
       all->draw.drawEndX = spriteWidth / 2 + all->sprite.ScreenX;
      if(all->draw.drawEndX >= all->rend.x) all->draw.drawEndX = all->rend.x - 1;

      //loop through every vertical stripe of the sprite on screen
      for(int stripe = all->draw.drawStartX; stripe < all->draw.drawEndX; stripe++)
      {
        int texX = (int)(256 * (stripe - (-spriteWidth / 2 + all->sprite.ScreenX)) * all->tex[g].tex_w / spriteWidth) / 256;
        if(all->sprite.tranY > 0 && stripe > 0 && stripe < all->rend.x && all->sprite.tranY < Zbuff[stripe])
        for(int y = all->draw.drawStartY; y < all->draw.drawEndY; y++) //for every pixel of the current stripe
        {
          int d = (y-all->sprite.move_s) * 256 - all->rend.y * 128 + all->tex[4].tex_h * 128; //256 and 128 factors to avoid floats
          int texY = ((d * all->tex[g].tex_w) / all->tex[4].tex_h) / 256;
          //Uint32 color = texture[sprite[spriteOrder[i]].texture][texWidth * texY + texX]; //get current color from the texture
          color = get_color(all, texX, texY, 4);
            if((color & 0x00FFFFFF) != 0)  //paint pixel if it isn't black, black is the invisible color
            my_mlx_pixel_put(all, stripe, y, color);
        }
      }
  }
   mlx_put_image_to_window(all->win.mlx, all->win.win, all->img.img, 0, 0);
    return (1);   
}